% Deve resumir o experimento, os resultados e a discussão (comentários)
% e incluir opiniões do grupo e propostas futuras para o experimento
%Descrição do hardware
%Descrição do software
%\cite{Advpdf}
%\cite{thepdf}
%\cite{dsl}

\subsection{Estruturas}\label{struct}

\subsubsection{Arquitetura}\label{arq}

No intuito de manter o jogo compatível com qualquer sistema operacional, foi decidido centralizar as inclusões de bibliotecas em um único arquivo. Para essa função foi criado o arquivo \textit{"defines.h"}, que é responsável por reconhecer o sistema em que esta sendo compilado e incluir os devidos \textit{headers}.

\begin{lstlisting}[language=C++,title=\textit{defines.h},firstnumber=5,numbers=none]
#if defined (__APPLE__) || defined (MACOSX) /*MAC OS*/
    #include <GLUT/glut.h>
#else
    #ifdef _WIN32                           /* Windows */
    	#define WIN32_LEAN_AND_MEAN
        #include <glee.h>
        #include <gl/gl.h>
		#include <gl/glut.h>
        #include <windows.h>
        #define sleep(x) Sleep(x)
    #else                                   /*Linux*/
    	#include <cstdarg>
    	#include <unistd.h>
        #include <GL/gl.h>
        #include <GL/glut.h>
        #include <GL/glu.h>
        #define Sleep(x) usleep(x<1000000?10000+300*x:x)
    #endif
#endif
\end{lstlisting}

No trecho mostrado acima, podemos ver como o programa reconhece em qual sistema esta sendo compilado e em qual endereço irá procurar pelas bibliotecas. A decisão é tomada de forma bem simples e objetiva, buscando apenas saber se as definições \textbf{MACOSX} ou \textbf{\_WIN32} existem. Com estas duas definições é suficiente para dividir entre os três sistemas operacionais que o programa se propõe a dar suporte. 

Porém este não é o único problema enfrentado quando se trata de um programa multiplataforma, mas também existem as dificuldades com a própria compilação.

Visando isso, foi feito um arquivo \textit{makefile} que procede com teste semelhante ao feito no \textit{defines.h} para verificar em que sistema se encontra e assim efetuar os links corretamente. Um trecho do \textit{makefile} pode ser observado a seguir:

\begin{lstlisting}[language=make,title=\textit{Makefile},firstnumber=8,numbers=none]
UNAME = $(shell uname)
ifeq ($(UNAME),Linux) # Linux OS
	GLFLAGS = -lglut -lglui -lGLU -lGL -lalut -lopenal
	else
	ifeq ($(UNAME),Darwin) # MAC OS X
		GLFLAGS=-framework OpenGL -framework GLUT
	else #Windows
		GLFLAGS=-lopengl32 -lglu32 -lglut32 -lalut
	endif
endif
\end{lstlisting}

É valido aproveitar a oportunidade para frisar no trecho mostrado acima do \textit{makefile} a inclusão das flags \textit{-lalut -lopenal} para inclusão de áudio no programa.

\subsubsection{Execução}\label{exe}

\paragraph{\textbf{Windows}}

O programa foi desenvolvido com auxilio da IDE \textit{CodeBlocks}\footnote{Acesse \url{http://www.codeblocks.org/} para maiores informações sobre a IDE.}. Assim, para gerar o executável na plataforma, basta abrir o arquivo \textit{Projeto - Labirinto.cbp} no \textit{CodeBlocks} e mandar compilar/construir o projeto. Na própria IDE haverá meios de executar o arquivo de saída, porém na pasta do projeto será possível localizar também o arquivo \textit{*.exe}.

\paragraph{\textbf{Linux}}

Para se construir o programa na plataforma Linux, é necessário ter algumas bibliotecas instaladas no sistema. Dentre elas é valido destacar as do OpenGL e de áudio (\textit{Alut} e \textit{Openal}). Na pasta onde se encontra os arquivos fontes, é possível localizar o arquivo \textit{makefile}. No terminal, basta executar o comando \textbf{make run} no diretorio contendo o arquivo \textit{makefile} para compilar os arquivos e inicializar o programa corretamente. Caso alguma das bibliotecas necessárias não estejam instaladas, será observado a lista de \textit{warnings/errors}, orientando qual biblioteca deve de ser instalada. É valido lembrar que para instalar as bibliotecas para este fim na plataforma Linux, deve-se buscar pelos nomes com o sufixo \textit{-dev}, garantindo assim que serão instalados os arquivos necessários. A compilação será feita de forma silenciosa e se não tiver problemas, apresentará uma saída semelhante a:

\begin{lstlisting}[language=bash,title=\textit{Saída do terminal - Linux},numbers=none]
$ make run
System: Linux OS
compiling...ok
Running...
\end{lstlisting}

\paragraph{\textbf{Mac OS}}

Semelhante aos passos no sistema Linux, o usuário terá que executar o comando \textbf{make run} no diretorio contendo o arquivo \textit{makefile} para compilar os arquivos e inicializar o programa corretamente. Se a compilação ocorrer corretamente, a saída deverá ser semelhante a:

\begin{lstlisting}[language=bash,title=\textit{Saída do terminal - Mac OS},numbers=none]
$ make run
System: Darwin
compiling...ok
Running...
\end{lstlisting}


\paragraph{\textbf{Valgrind/Callgrind}}

No intuito de melhor observar como o programa se comportava durante sua execução, utilizamos da ferramenta do \textit{Valgrind} para visualizar a sequencia de chamadas efetuadas no programa.
Para isso foi incorporado no \textit{Makefile} a chamada para o Valgrind, onde uma nova compilação ocorre sem as chamadas de otimização e verificação de erros seguida da chamada do Valgrind para a geração de um arquivo \textit{Callgrind.out}. Este arquivo pode ser utilizado para gerar um gráfico com as chamadas realizadas pelo programa \textit{KCachegrind} semelhante ao gerado na imagem \ref{valgrind}. É valido lembrar que o Valgrind roda com memoria limitada. Por este motivo, ele não permite realizar o monitoramento do programa por períodos muito extensos. O gráfico apresentado na figura \ref{valgrind} foi gerado disponibilizando apenas 16MB para captura de dados no Valgrind \cite{valgrind}, como pode ser observado no trecho do manual:

\selectlanguage{english}
\begin{quote}
	\textit{By default, Valgrind uses the current "ulimit" value for the stack size, or 16 MB, whichever is lower. In many cases this gives a stack size in the
           range 8 to 16 MB, which almost never overflows for most applications.}\cite{valgrind}
\end{quote}
\selectlanguage{brazil}

Normalmente, faríamos da seguinte forma para usar o Valgrind:

\begin{lstlisting}[language=bash,title=\textit{Gerando arquivo callgrind.out},numbers=none]
$ make valgrind
	g++ -g *.cpp -o prog -lglut -lglui -lGLU -lGL -lalut  -lopenal
	valgrind --tool=callgrind --dsymutil=yes 
		--trace-jump=yes ./prog
\end{lstlisting}

Porém algumas opções foram incluídas para ter uma resposta mais apropriada. A primeira alteração trata-se da forma de compilação. Ao invés de compilar todos os arquivos diretamente, foi criado uma biblioteca dinâmica, para que o executável final carregue apenas as funções que realmente foram usadas - já que nosso código ainda carrega algumas funções para debug.

\begin{lstlisting}[language=bash,title=\textit{Gerando uma biblioteca dinâmica},numbers=none]
	g++ -g -c button.cpp  defines.cpp   eventos.cpp  minimap.cpp  soundAL.cpp  textureloader.cpp camera.cpp  entidade.cpp  framerate.cpp  map.cpp          player.cpp   text.cpp     tile.cpp
	ar rc libAmaze.a *.o
\end{lstlisting}

Em seguida, utilizamos a biblioteca dinâmica para compilar o arquivo principal do jogo. Essa atitude permite que o binário carregue menos informações, o que implica em uma quantidade de memoria menor reservada no Valgrind.

\begin{lstlisting}[language=bash,title=\textit{Compilando com a biblioteca dinâmica},numbers=none]
	g++ -g gamemanager.cpp -o ToGring -lglut -lglui -lGLU 
-lGL -lalut  -lopenal -L./ -lAmaze
\end{lstlisting}

Assim, temos um novo binario - ToGrind - contendo apenas as funções realmente utilizadas no programa. Por fim, chamamos o Valgrind, passando algumas opções a mais:

\begin{lstlisting}[language=bash,title=\textit{Chamada personalizada do Valgrind},numbers=none]
	valgrind --tool=callgrind --dsymutil=yes ./ToGring -q 
--fullpath-after=string  --show-possibly-lost=yes 
--trace-children=yes -v --main-stacksize=512MB
\end{lstlisting}

Seguem a lista de alterações passadas para o Valgrind:

\begin{enumerate}
	\item \textbf{fullpath-after:} Essa opção é importante para programas que contenham muitos arquivos em distintos diretórios.
	\item \textbf{show-possibly-lost:} Mostra possíveis blocos de memoria perdidos.
	\item \textbf{trace-children:} Caso o programa produza processos filhos, eles serão acompanhados também.
	\item \textbf{main-stacksize:} Altera o tamanho de memoria reservado para captura de dados.
\end{enumerate}

\subsubsection{Artefatos}\label{artefatos}

\paragraph{\textbf{Arquivos}}

Arquivos utilizados na construção do programa\footnote{Atualizado em 10 de Setembro de 2012}:\\

\begin{itemize}
	\item button.cpp
	\item button.h
	\item camera.cpp
	\item camera.h
	\item defines.cpp
	\item defines.h
	\item entidade.cpp
	\item entidade.h
	\item eventos.cpp
	\item eventos.h
	\item framerate.cpp
	\item framerate.h
	\item gamemanager.cpp
	\item gamemanager.h
	\item map.cpp
	\item map.h
	\item minimap.cpp
	\item minimap.h
	\item player.cpp
	\item player.h
	\item soundAL.cpp
	\item soundAL.h
	\item text.cpp
	\item text.h
	\item textureloader.cpp
	\item textureloader.h
	\item tile.cpp
	\item tile.h
	\item vetor3d.h
	\item vetor.h
	
\end{itemize}

\paragraph{\textbf{README}}

O arquivo README pode ser localizado dentre os arquivos fontes, em \ref{README}. Nele há algumas informações sobre como o programa foi desenvolvido e uma breve instrução de como construir o jogo a partir do código fonte.

\subsubsection{Problemas Técnicos}\label{problens}

\paragraph{\textbf{Inconsistencias entre sistemas operacionais:}}
%Inconsistencias entre sistemas operacionais:
Ao apertar Shift para correr após já estar se movendo em windows o SO windows 
não envia o evento e portanto não realiza a corrida. Ao passo que no SO linux o evento 
é enviado e o jogador começa a corrida, como deveria.

\paragraph{\textbf{Frame rate:}}
%Frame rate:
O sistema utiliza-se de um frame cap de 60 FPS. Porém ocorre certas divergencias 
devido aos sleep's do windows e do linux serem um pouco diferentes entre si.

%\footnote{A home-page de onde tirei
%este material:\url{http://en.wikibooks.org/wiki/LaTeX}.Estou formatando para \LaTeX apenas para os estudantes irem se orientando de como e o quê escrever.Assim, me isento de responsabilidade sobre o conteúdo deste texto. Dúvidas: carla(rocha.carla@gmail.com)}


